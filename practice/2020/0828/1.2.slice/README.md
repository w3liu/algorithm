# slice数据结构
```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

# 使用make创建slice
`slice := make([]int, 5, 10)`
slice的长度为5，可以使用slice[0]~slice[4]来操作里边的元素，capacity为10，表示后续向slice添加的新元素时可以不必分配内存，直接使用预留内存即可。

# 使用数组创建slice
`slice := array[5:7]`
切片从array[5]开始，到数组array[7]结束（不含array[7]）,切片长度为2

# slice扩容
    * 如果原slice容量小于1024，则新slice容量将扩大为原来的2倍；
    * 如果原slice容量大于等于1024，则新slice容量将扩大为原来的1.25倍；
    * 使用append()向sice添加一个元素的实现步骤如下：
        * 假如slice容量够用，则将新元素追加进去，slice.len++，返回slice
        * 原slice容量不够，则将slice先扩容，扩容后得到新slice
        * 将新元素追加金新slice，slice.len++，返回新slice。
# slice copy
使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。

例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。

也就是说，copy过程中不会发生扩容。

# 特殊切片
`slice[strart:end:cap]`
其中cap为新切片的容量，容量不能超过原切片实际值

# 编程tips
    * 创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；
    * 切片拷贝时需要判断实际拷贝的元素个数
    * 谨慎使用多个切片操作同一个数组，以防读写冲突
# 总结
    * 每个切片都指向一个底层数组
    * 每个切片都保存了当前切片的长度、底层数组的可用容量
    * 使用len()计算切片长度时间复杂度为O(1),不需要遍历切片
    * 使用cap()计算切片容量时间复杂度为O(1),不需要遍历切片
    * 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已
    * 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片