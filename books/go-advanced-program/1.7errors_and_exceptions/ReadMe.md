* Go语言库的实现习惯：即使在包内使用了panic，但是在导出函数时会被转化为明确的错误值。
* 检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。
* 如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应放在函数体中。
* 不同类型之间必须要显式转换。但是，Go语言中interface是一个例外；非接口类型到接口类型，或者接口类型之间的转换都是隐式的。
* 当函数panic抛出异常，函数将停止执行后续的普通语句，但是之前注册的defer函数调用任然保证会被正常执行，然后再返回到调用者。
* recover函数有着更严格的要求：我们必须在defer函数中直接调用recover。如果defer中调用的是recover函数的包装函数的话，异常的捕获工作将失败！
