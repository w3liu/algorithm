# 2022.02.07-2022.02.13

## Algorithm
### 1. 题目
```
287. 寻找重复数
```
### 2. 题目描述
```
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：

输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3
```

### 3. 解答：
```golang
func findDuplicate(nums []int) int {
	var slow = nums[0]
	var fast = nums[nums[0]]
	for slow != fast {
		slow = nums[slow]
		fast = nums[nums[fast]]
	}

	var after = 0
	for after != slow {
		slow = nums[slow]
		after = nums[after]
	}

	return slow
}
```
### 4. 说明
slow = fast 时，快慢指针相遇，slow 走过的距离是初始点（0）到环状开始的点 （x） 加上 环状开始的点（x） 到相遇点（y） 这段距离，而fast走过的距离是 初始点（0）到环状开始的点（x），点（x） 到点（y），点（y）到点（x），点（x）到点（y）。

又因为fast走过的距离是low的两倍，设0到x长度为a，x到y长度为b,则有2*（a+b） = a+ b+ (y到x的距离) + b，则y到x的距离就等于0到x的距离。

所以当新的两个指针 一个从0出发，一个从相遇点y出发时，他们走到的相同的值就是环状开始的点，即x点。

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### Makefile使用函数
* 函数的调用语法
```
$(<function> <arguments>)
```
或是
```
${<function> <arguments>}
```
参数以逗号分隔

示例：
```
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
```
subst 是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串.
所以，$(bar)的值是a,b,c

* 字符串处理函数
    * subst
    ```
    $(subst <from>,<to>,<text>)
    ```
    把字符串<text>中的<from>替换为<to>。
    * patsubst 
    ```
    $(patsubst <pattern>,<replacement>,<text>)
    ```
    查找 <text> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern> ，如果匹配的话，则以 <replacement> 替换。
    这里，<pattern> 可以包括通配符 % ，表示任意长度的字串。
    如果 <replacement> 中也包含 % ，那么，<replacement> 中的这个 % 将是<pattern> 中的那个 % 所代表的字串。（可以用 \ 来转义，以 \% 来表示真实含义的 % 字符）
    
    示例：
    ```
    $(patsubst %.c,%.o,x.c.c bar.c)
    ```
    把字符串x.c.c bar.c符合模式%.c的单词替换为%.o，返回结果是x.c.o bar.o
    
    * strip
    ```
    $(strip <string>)
    ```
    去掉<string>字符串开头和结尾的空字符串。
    
    示例：
    ```
    $(strip a b c )
    ```
    把字符串 `a b c `去掉开头和结尾的空格，结果是  `a b c`
    
    * findstring
    ```
    $(findstring <find>,<in>)
    ```
    在子串<in>中查找<find>字串
    
    * filter
    ```
    $(filter <pattern...>,<text>)
    ```
    以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。
    
    示例：
    ```
    sources := foo.c bar.c baz.s ugh.h
    foo: $(sources)
        cc $(filter %.c %.s,$(sources)) -o foo
    ```
    返回值是foo.c bar.c baz.s
    
    * filter-out
    ```
    $(filter-out <pattern>,<text>)
    ```
    以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。
    
    示例：
    ```
    objects=main1.o foo.o main2.o bar.o
    mains=main1.o main2.o
    $(filter-out $(mains),$(objects))
    ```
    返回值是foo.o bar.o
    
    * sort
    ```
    $(sort <list>)
    ```
    给字符串<list> 中的单词排序（升序）。
    
    示例：
    ```
    $(sort foo bar lose)
    ```
    返回值是 bar foo lose
    
    备注：sort函数会去掉<list>中相同的单词。
    
    * word
    ```
    $(word <n>,<text>)
    ```
    去字符串<text>中第<n>个单词。(从一开始)
    
    示例：
    ```
    $(word 2, foo bar baz)
    ```
    返回值是bar。
    
    * wordlist
    ```
    $(wordlist <ss>,<e>,<text>)
    ```
    从字符串 <text> 中取从 <ss> 开始到 <e> 的单词串。<ss> 和 <e> 是一个数字。
    
    示例：
    ```
    $(wordlist 2, 3, foo bar baz) 
    ```
    返回值是bar baz。
    
    * words
    ```
    $(words <text>)
    ```
    统计 <text> 中字符串中的单词个数。
    
    示例：
    ```
    $(words, foo bar baz)
    ```
    返回值是3。
    
    * firstword
    ```
    $(firstword <text>)
    ```
    取字符串<text>中的第一个单词。
    
    示例：
    ```
    $(firstword foo bar)
    ```
    返回值是foo。

一个比较复杂的例子：
```
override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
```
如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH)))
将返回 -Isrc -I../headers ，这正是 cc 或 gcc 搜索头文件路径的参数。

## Share
### 标题