# 2022.06.06-2022.06.12

## Algorithm
### 1. 题目
```
461. 汉明距离
```
### 2. 题目描述
```
两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

 

示例 1：

输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
示例 2：

输入：x = 3, y = 1
输出：1
```

### 3. 解答：
```golang
func hammingDistance(x int, y int) int {
	return bits.OnesCount(uint(x ^ y))
}
```
### 4. 说明
异或，再统计1的个数即可。

## Review
### 1. 原文链接
[http://blog.cleancoder.com/uncle-bob/2015/10/30/FutureProof.html](http://blog.cleancoder.com/uncle-bob/2015/10/30/FutureProof.html)

### 2. 翻译
Future Proof

前瞻性

I recently read Christin Gorman’s blog Future Proof. 
In it she lambastes the idea that you can create code that is protected from future change.

我最近读了克里斯汀·戈尔曼的博客Future Proof。
在书中，她痛斥了这样一种想法:你可以创建不受未来更改影响的代码。

Awesome or not, some things are impossible. 
Cordless garden hoses are impossible. 
So is software that changes without being changed. 
If you need it to adapt to future requirements, then guess what: that involves adaptation – AKA change.

不管是否了不起，有些事情是不可能的。
无绳花园软管是不可能的。
软件在不被更改的情况下更改也是如此。
如果你需要它来适应未来的需求，那么你猜怎么着:这涉及到适应——也就是改变。

She’s right about that, of course. 
When the requirements change, either some code, or some data is going to have to change. 
The Open-Closed Principle cannot apply to every element of the system. 
No matter how open you make your system to extension, something, somewhere will need modification.

当然，她是对的。
当需求改变时，要么一些代码，要么一些数据将不得不改变。
开闭原理不能适用于系统的每一个元素。
无论您的系统对扩展的开放程度有多高，总有一些地方需要修改。

External Data

外部数据

Indeed, Gorman rants rather poetically about the notion that changes to an .xml file, or a database table, are somehow better than changes to source code.

事实上，Gorman相当诗意地咆哮着这样一个概念:改变一个.xml文件或数据库表，在某种程度上比改变源代码要好。

Moving changes outside the code itself does in NO WAY stop you from having to make changes. 
It does however create extra complexity in the code, while limiting the types of changes you can make. 
It also makes it much harder to track the changes made, who made them, when were they made and by whom. 
So if you like the idea of allowing random changes in your production environment, with limited accountability or ability to keep track of what’s going on – by all means move all your settings to your database, or properties files. Have fun.

将更改移到代码本身之外并不能阻止您进行更改。
然而，它确实增加了代码的复杂性，同时限制了您可以进行的更改类型。
它还使跟踪所做的更改、谁做的更改、何时做的更改以及由谁做的更改变得更加困难。
因此，如果您喜欢在您的生产环境中允许随机更改的想法，并具有有限的责任性或跟踪所发生的事情的能力，那么请务必将所有设置移到数据库或属性文件中。玩得开心。

At this point you are probably saying to yourself: “Yeah, but…”

这时候你可能会对自己说:“是啊，但是……”

Let’s explore that “but…”

让我们来探讨一下“但是……”

In most systems there are some system parameters that vary between different installations. 
Such parameters clearly belong outside the code. We don’t want to have to compile different versions of the code for different customers.

在大多数系统中，有一些系统参数因不同的安装而不同。
这些参数显然属于代码之外。我们不想为不同的客户编译不同版本的代码。

In fact most systems have certain parameters that the users want to change on a whim without involving the developers who compile the system. 
Consider for example, a security system that sends a text message to a security guard whenever there is a security event. 
It would be a real shame if the supplier of that security system had to recompile and redeploy their code every time the security guard’s phone number changed.

事实上，大多数系统都有某些用户想要随意更改的参数，而不需要编译系统的开发人员参与。
例如，一个安全系统在发生安全事件时向安全警卫发送一条短信。
如果每次保安的电话号码改变时，安全系统的供应商都必须重新编译和重新部署他们的代码，那将是一件非常遗憾的事情。

So, for the sake of argument, let’s assume that Gorman would acknowledge that there are some data elements that belong outside of the application and in a text file, or an xml file or a properties file. 
What rule can we use to tell which data elements should be inside the code, and which should be outside the code.

因此，为了便于讨论，我们假设Gorman会承认有些数据元素属于应用程序之外，存在于文本文件、xml文件或属性文件中。
我们可以使用什么规则来告诉哪些数据元素应该在代码内部，哪些应该在代码外部。

The answer to that is trivial. 
Anything that the programmers don’t want to be bothered with on a regular basis should be outside the code. 
What kinds of things bother the programmers? Things that change frequently.

这个问题的答案很简单。
程序员不希望在常规基础上被打扰的任何事情都应该在代码之外。
什么样的事情会困扰程序员?经常变化的东西。

So our rule is: Anything that changes frequently should be outside the code.

所以我们的规则是:任何频繁更改的内容都应该在代码之外

Decoupling Modules

解耦模块

Gorman continues.

戈尔曼还在继续。

If you want a future proof system, you don’t want immortal and flexible code. 
You don’t want the T1000 terminator. 
You want Southpark’s Kenny. You need code that’s easy and fun to kill. 
You need to get used to killing it, often, so you can replace it with whatever you end up needing.

如果您想要一个未来的证明系统，您不需要不朽和灵活的代码。
你不想要T1000终结者。
你想要南方公园的肯尼。你需要编写易于编写且有趣的代码。
你需要习惯经常杀死它，这样你就可以用你最终需要的任何东西来替代它。

This is generally very good advice. 
It is better to create a changeable system than to try to protect all parts of the system from change. 
However, there are issues with creating code that’s easy to change (or “kill”).

这是一个很好的建议。
与其试图保护系统的所有部分不受变化的影响，不如创建一个可变的系统。
然而，创建容易更改(或“杀死”)的代码存在问题。

If killing or modifying a particular module causes many others modules to break, either at compile time, or at test time, then the cost of making that change (the impact) is going to be high. Sometimes it can be very high. I have worked on systems where the impact of certain changes was so prohibitive that they were delayed for years.

What causes this to happen? Why does changing certain modules affect others? Dependencies, of course.

When one module depends upon the internals of another; then when those internals change, both modules will require changes. Dependencies like this can propagate through a system making it very hard to change. So certainly we’d like to mitigate this by somehow decoupling the modules that need to be changed, from the rest of the system.

Which modules should be decoupled? I think the rule is similar to the previous rule: Any module that changes frequently should be decoupled from the rest of the system.

How do you decouple one module from another? That depends on the level of decoupling you need. Sometimes simply extracting that code into a separate function is enough. More often, it’s better to move all the related code into a separate class, and even a separate source file. And in extreme cases, you want to put those classes behind polymorphic interfaces.

###Interfaces And this is where I part company from Gorman to a certain extent. Because she goes on:

Java interfaces are meant to be used when there are a bunch of implementations available, and your code wants to access them all in the same manner.

And again…

Interfaces with only one implementation are the committees of code. If you don’t want to make a decision yourself, if you’re worried about being blamed if it was wrong, you delegate it to a committee.

Actually she rants much longer about this; and even refers to the satirical EnterpriseFizzBuzz as an example of code that is “not far from the reality out there”.

In general I agree that using polymorphic interfaces without good reason is overkill. But I am not at all opposed to having interfaces with a single implementation. Sometimes the decoupling that provides is exactly right for isolating a module that changes frequently. One should not look at Enterprise Fizz Buzz and conclude that interfaces should be avoided at all costs.

Tests
Finally, as she continues her rant against interfaces, Gorman asserts that interfaces don’t make testing easier.

Some will tell you that interfaces are great for making your code testable. No they aren’t. They do no harm, but they don’t help either. You don’t need interfaces to create mocks or stubs or spies. Use Mockito or any other sensible mocking framework, and you can easily create mocks for concrete classes. You should also ask yourself why you need those mocks or stubs or spies – with a little rework of your code, you might be able to write tests with very little mocking:

I can sympathize with that last point. I think that many software teams use mocks more than they should. I use mocks with a certain parsimony. I will mock; but usually only across significant architectural boundaries. I don’t mock every class and every function. But when I am facing a significant boundary, mocks are very useful, and therefore interfaces become essential.

About Gorman’s middle point, that you can always use a mocking tool like Mockito in order to avoid interfaces, I’ll say two things.

The choice to use a tool, like Mockito, should not be motivated by a resistance to interfaces. Interfaces should not be actively avoided. Being restrained is not the same as being repelled.

I don’t often use mocking tools because I write my own mocks. So I find interfaces quite helpful.

That last point may strike some of you as odd; but it’s true. Mocks are very easy to hand write; and hand written mocks can be given nice names, and placed in nicely named packages, and nicely named source files, and nicely named directories. Hand written mocks don’t pollute your setups with random sequences of dots and parentheses. So, unless I need a mocking tool’s super powers, I tend not to use them.

So in the end, I don’t completely agree with Gorman’s initial assertion. Interfaces may not always make testing easier; but at certain boundaries they are absolutely essential.

###Bottom Line For the most part, I think Gorman made some good points. The goal is not to “Future Proof” your code. The future will aways find a way to thwart you.

However, that doesn’t mean that you shouldn’t arrange your code to minimize the impact of frequent change. And if you can do that by externalizing certain data elements, and putting certain modules behind polymorphic interfaces, there’s no reason you shouldn’t. Decoupling shouldn’t be gratuitous; but it’s not something to actively avoid. Indeed, strategic decoupling in moderation is a very, very good thing.

Finally, Gorman herself acknowledges that if you don’t make things easy to change, the cost can be very high.

_ In Norway our parliament voted to change our criminal laws in 2005. But they have only now (2015) been put into full effect, because the police’s computer systems prevented them from applying the new rules._

### 3. 点评


## Tip
### 标题


## Share
### 标题