# 2022.06.06-2022.06.12

## Algorithm
### 1. 题目
```
461. 汉明距离
```
### 2. 题目描述
```
两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

 

示例 1：

输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
示例 2：

输入：x = 3, y = 1
输出：1
```

### 3. 解答：
```golang
func hammingDistance(x int, y int) int {
	return bits.OnesCount(uint(x ^ y))
}
```
### 4. 说明
异或，再统计1的个数即可。

## Review
### 1. 原文链接
[http://blog.cleancoder.com/uncle-bob/2015/10/30/FutureProof.html](http://blog.cleancoder.com/uncle-bob/2015/10/30/FutureProof.html)

### 2. 翻译
Future Proof

前瞻性

I recently read Christin Gorman’s blog Future Proof. 
In it she lambastes the idea that you can create code that is protected from future change.

我最近读了克里斯汀·戈尔曼的博客Future Proof。
在书中，她痛斥了这样一种想法:你可以创建不受未来更改影响的代码。

Awesome or not, some things are impossible. 
Cordless garden hoses are impossible. 
So is software that changes without being changed. 
If you need it to adapt to future requirements, then guess what: that involves adaptation – AKA change.

不管是否了不起，有些事情是不可能的。
无绳花园软管是不可能的。
软件在不被更改的情况下更改也是如此。
如果你需要它来适应未来的需求，那么你猜怎么着:这涉及到适应——也就是改变。

She’s right about that, of course. 
When the requirements change, either some code, or some data is going to have to change. 
The Open-Closed Principle cannot apply to every element of the system. 
No matter how open you make your system to extension, something, somewhere will need modification.

当然，她是对的。
当需求改变时，要么一些代码，要么一些数据将不得不改变。
开闭原理不能适用于系统的每一个元素。
无论您的系统对扩展的开放程度有多高，总有一些地方需要修改。

External Data

外部数据

Indeed, Gorman rants rather poetically about the notion that changes to an .xml file, or a database table, are somehow better than changes to source code.

事实上，Gorman相当诗意地咆哮着这样一个概念:改变一个.xml文件或数据库表，在某种程度上比改变源代码要好。

Moving changes outside the code itself does in NO WAY stop you from having to make changes. 
It does however create extra complexity in the code, while limiting the types of changes you can make. 
It also makes it much harder to track the changes made, who made them, when were they made and by whom. 
So if you like the idea of allowing random changes in your production environment, with limited accountability or ability to keep track of what’s going on – by all means move all your settings to your database, or properties files. Have fun.

将更改移到代码本身之外并不能阻止您进行更改。
然而，它确实增加了代码的复杂性，同时限制了您可以进行的更改类型。
它还使跟踪所做的更改、谁做的更改、何时做的更改以及由谁做的更改变得更加困难。
因此，如果您喜欢在您的生产环境中允许随机更改的想法，并具有有限的责任性或跟踪所发生的事情的能力，那么请务必将所有设置移到数据库或属性文件中。玩得开心。

At this point you are probably saying to yourself: “Yeah, but…”

这时候你可能会对自己说:“是啊，但是……”

Let’s explore that “but…”

让我们来探讨一下“但是……”

In most systems there are some system parameters that vary between different installations. 
Such parameters clearly belong outside the code. We don’t want to have to compile different versions of the code for different customers.

在大多数系统中，有一些系统参数因不同的安装而不同。
这些参数显然属于代码之外。我们不想为不同的客户编译不同版本的代码。

In fact most systems have certain parameters that the users want to change on a whim without involving the developers who compile the system. 
Consider for example, a security system that sends a text message to a security guard whenever there is a security event. 
It would be a real shame if the supplier of that security system had to recompile and redeploy their code every time the security guard’s phone number changed.

事实上，大多数系统都有某些用户想要随意更改的参数，而不需要编译系统的开发人员参与。
例如，一个安全系统在发生安全事件时向安全警卫发送一条短信。
如果每次保安的电话号码改变时，安全系统的供应商都必须重新编译和重新部署他们的代码，那将是一件非常遗憾的事情。

So, for the sake of argument, let’s assume that Gorman would acknowledge that there are some data elements that belong outside of the application and in a text file, or an xml file or a properties file. 
What rule can we use to tell which data elements should be inside the code, and which should be outside the code.

因此，为了便于讨论，我们假设Gorman会承认有些数据元素属于应用程序之外，存在于文本文件、xml文件或属性文件中。
我们可以使用什么规则来告诉哪些数据元素应该在代码内部，哪些应该在代码外部。

The answer to that is trivial. 
Anything that the programmers don’t want to be bothered with on a regular basis should be outside the code. 
What kinds of things bother the programmers? Things that change frequently.

这个问题的答案很简单。
程序员不希望在常规基础上被打扰的任何事情都应该在代码之外。
什么样的事情会困扰程序员?经常变化的东西。

So our rule is: Anything that changes frequently should be outside the code.

所以我们的规则是:任何频繁更改的内容都应该在代码之外

Decoupling Modules

解耦模块

Gorman continues.

戈尔曼还在继续。

If you want a future proof system, you don’t want immortal and flexible code. 
You don’t want the T1000 terminator. 
You want Southpark’s Kenny. You need code that’s easy and fun to kill. 
You need to get used to killing it, often, so you can replace it with whatever you end up needing.

如果您想要一个未来的证明系统，您不需要不朽和灵活的代码。
你不想要T1000终结者。
你想要南方公园的肯尼。你需要编写易于编写且有趣的代码。
你需要习惯经常杀死它，这样你就可以用你最终需要的任何东西来替代它。

This is generally very good advice. 
It is better to create a changeable system than to try to protect all parts of the system from change. 
However, there are issues with creating code that’s easy to change (or “kill”).

这是一个很好的建议。
与其试图保护系统的所有部分不受变化的影响，不如创建一个可变的系统。
然而，创建容易更改(或“杀死”)的代码存在问题。

If killing or modifying a particular module causes many others modules to break, either at compile time, or at test time, then the cost of making that change (the impact) is going to be high. Sometimes it can be very high. I have worked on systems where the impact of certain changes was so prohibitive that they were delayed for years.

What causes this to happen? Why does changing certain modules affect others? Dependencies, of course.

When one module depends upon the internals of another; then when those internals change, both modules will require changes. Dependencies like this can propagate through a system making it very hard to change. So certainly we’d like to mitigate this by somehow decoupling the modules that need to be changed, from the rest of the system.

Which modules should be decoupled? I think the rule is similar to the previous rule: Any module that changes frequently should be decoupled from the rest of the system.

How do you decouple one module from another? That depends on the level of decoupling you need. Sometimes simply extracting that code into a separate function is enough. More often, it’s better to move all the related code into a separate class, and even a separate source file. And in extreme cases, you want to put those classes behind polymorphic interfaces.

###Interfaces And this is where I part company from Gorman to a certain extent. Because she goes on:

Java interfaces are meant to be used when there are a bunch of implementations available, and your code wants to access them all in the same manner.

And again…

Interfaces with only one implementation are the committees of code. If you don’t want to make a decision yourself, if you’re worried about being blamed if it was wrong, you delegate it to a committee.

Actually she rants much longer about this; and even refers to the satirical EnterpriseFizzBuzz as an example of code that is “not far from the reality out there”.

In general I agree that using polymorphic interfaces without good reason is overkill. But I am not at all opposed to having interfaces with a single implementation. Sometimes the decoupling that provides is exactly right for isolating a module that changes frequently. One should not look at Enterprise Fizz Buzz and conclude that interfaces should be avoided at all costs.

Tests
Finally, as she continues her rant against interfaces, Gorman asserts that interfaces don’t make testing easier.

Some will tell you that interfaces are great for making your code testable. No they aren’t. They do no harm, but they don’t help either. You don’t need interfaces to create mocks or stubs or spies. Use Mockito or any other sensible mocking framework, and you can easily create mocks for concrete classes. You should also ask yourself why you need those mocks or stubs or spies – with a little rework of your code, you might be able to write tests with very little mocking:

I can sympathize with that last point. I think that many software teams use mocks more than they should. I use mocks with a certain parsimony. I will mock; but usually only across significant architectural boundaries. I don’t mock every class and every function. But when I am facing a significant boundary, mocks are very useful, and therefore interfaces become essential.

About Gorman’s middle point, that you can always use a mocking tool like Mockito in order to avoid interfaces, I’ll say two things.

The choice to use a tool, like Mockito, should not be motivated by a resistance to interfaces. Interfaces should not be actively avoided. Being restrained is not the same as being repelled.

I don’t often use mocking tools because I write my own mocks. So I find interfaces quite helpful.

That last point may strike some of you as odd; but it’s true. Mocks are very easy to hand write; and hand written mocks can be given nice names, and placed in nicely named packages, and nicely named source files, and nicely named directories. Hand written mocks don’t pollute your setups with random sequences of dots and parentheses. So, unless I need a mocking tool’s super powers, I tend not to use them.

So in the end, I don’t completely agree with Gorman’s initial assertion. Interfaces may not always make testing easier; but at certain boundaries they are absolutely essential.

###Bottom Line For the most part, I think Gorman made some good points. The goal is not to “Future Proof” your code. The future will aways find a way to thwart you.

However, that doesn’t mean that you shouldn’t arrange your code to minimize the impact of frequent change. And if you can do that by externalizing certain data elements, and putting certain modules behind polymorphic interfaces, there’s no reason you shouldn’t. Decoupling shouldn’t be gratuitous; but it’s not something to actively avoid. Indeed, strategic decoupling in moderation is a very, very good thing.

Finally, Gorman herself acknowledges that if you don’t make things easy to change, the cost can be very high.

_ In Norway our parliament voted to change our criminal laws in 2005. But they have only now (2015) been put into full effect, because the police’s computer systems prevented them from applying the new rules._

### 3. 点评


## Tip
### Nginx限流
#### 限流算法
1. 令牌桶限流
```
令牌以固定速率产生，并缓存到令牌桶中；
令牌桶放满时，多余的令牌被丢弃；
请求要消耗等比例的令牌才能被处理；
令牌不够时，请求被缓存；
```
2. 漏桶算法
```
水（请求）从上方导入水桶，从水桶下方流出（被处理）；
来不及流出的水存在水桶中（缓冲），以固定速率流出；
水桶满后水溢出（丢弃）；
这个算法的核心是：缓存请求，匀速处理、多余的请求直接丢弃
```
Nginx按请求速率限速模块使用的事漏桶算法，能够强行保证请求的实时处理速度不会超过设置的阈值。

Nginx官方版本限制IP的连接和并发分别有两个模块：
- limit_req_zone 用来限制单位时间内的请求数，即速率限制，采用的漏桶算法`leaky_bucket`。
- limit_req_conn 用来限制同一时间连接数，即并发限制。

#### limit_req_zone参数配置
```
Syntax:	limit_req zone=name [burst=number] [nodelay];
Default:	—
Context:	http, server, location
```

`limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;`

- 第一个参数：$binary_remote_addr 表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。
- 第二个参数：zone=one:10m表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。
- 第三个参数：rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。

`limit_req zone=one burst=5 nodelay;`

- 第一个参数：zone=one 设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应。
- 第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。
- 第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。

例子：
```
http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        location /search/ {
            limit_req zone=one burst=5 nodelay;
    }
}
```
下面配置可以限制特定UA（比如搜索引擎）的访问：
```
limit_req_zone  $anti_spider  zone=one:10m   rate=10r/s;
limit_req zone=one burst=100 nodelay;
if ($http_user_agent ~* "googlebot|bingbot|Feedfetcher-Google") {
    set $anti_spider $http_user_agent;
}
```
其他参数
```
Syntax:	limit_req_log_level info | notice | warn | error;
Default:	
limit_req_log_level error;
Context:	http, server, location
```
当服务器由于limit被限速或缓存时，配置写入日志。延迟的记录比拒绝的记录低一个级别。
例子：`limit_req_log_level` notice延迟的的基本是info。
```
Syntax:	limit_req_status code;
Default:	
limit_req_status 503;
Context:	http, server, location
```
设置拒绝请求的返回值。值只能设置 400 到 599 之间。

#### ngx_http_limit_conn_module 参数配置

这个模块用来限制单个IP的请求数。并非所有的连接都被计数。只有在服务器处理了请求并且已经读取了整个请求头时，连接才被计数。
```
Syntax:	limit_conn zone number;
Default:	—
Context:	http, server, location
```
```
limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    location /download/ {
        limit_conn addr 1;
    }
```
一次只允许每个IP地址一个连接。
```
limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;

server {
    ...
    limit_conn perip 10;
    limit_conn perserver 100;
}
```
可以配置多个limit_conn指令。例如，以上配置将限制每个客户端IP连接到服务器的数量，同时限制连接到虚拟服务器的总数。
```
Syntax:	limit_conn_zone key zone=name:size;
Default:	—
Context:	http
```
```
limit_conn_zone $binary_remote_addr zone=addr:10m;
```
在这里，客户端IP地址作为关键。请注意，不是$ remote_addr，而是使用$ binary_remote_addr变量。 $ remote_addr变量的大小可以从7到15个字节不等。存储的状态在32位平台上占用32或64字节的内存，在64位平台上总是占用64字节。对于IPv4地址，$ binary_remote_addr变量的大小始终为4个字节，对于IPv6地址则为16个字节。存储状态在32位平台上始终占用32或64个字节，在64位平台上占用64个字节。一个兆字节的区域可以保持大约32000个32字节的状态或大约16000个64字节的状态。如果区域存储耗尽，服务器会将错误返回给所有其他请求。
```
Syntax:	limit_conn_log_level info | notice | warn | error;
Default:	
limit_conn_log_level error;
Context:	http, server, location
```
当服务器限制连接数时，设置所需的日志记录级别。
```
Syntax:	limit_conn_status code;
Default:	
limit_conn_status 503;
Context:	http, server, location
```
设置拒绝请求的返回值。

参考资料：[https://www.cnblogs.com/biglittleant/p/8979915.html](https://www.cnblogs.com/biglittleant/p/8979915.html)

## Share
### 软件工程师必读的13本书
[https://www.cnblogs.com/myshowtime/p/16377077.html](https://www.cnblogs.com/myshowtime/p/16377077.html)