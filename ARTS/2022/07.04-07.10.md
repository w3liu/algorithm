# 2022.07.04-2022.07.10

## Algorithm
### 1. 题目
```
560. 和为 K 的子数组
```
### 2. 题目描述
```
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数。

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2
```

### 3. 解答：
```golang
func subarraySum(nums []int, k int) int {
	var ret int
	for i := 0; i < len(nums); i++ {
		var ss int
		for y := i; y < len(nums); y++ {
			ss = ss + nums[y]
			if ss == k {
				ret++
			}
		}
	}
	return ret
}
```
### 4. 说明
第一重遍历确定子串的起始值，第二重遍历是寻找完所有的子串，如果发现ss==k不用break。

## Review
### 1. 原文链接
[http://blog.cleancoder.com/uncle-bob/2016/01/14/Stabilization.html](http://blog.cleancoder.com/uncle-bob/2016/01/14/Stabilization.html)

### 2. 翻译
Stabilization Phases

稳定阶段

While sipping my morning coffee, and scrolling through facebook on my phone, 
I found myself inundated with updates by Tesla owners who were excited that their cars could now drives themselves into a garage. 
My response to those facebook updates was perhaps a little cynical; but I told them all:

我一边喝着早上的咖啡，一边刷着手机上的faceboo，
我发现自己被特斯拉车主的更新淹没了，他们对自己的车现在可以自动开进车库感到兴奋。
我对这些facebook更新的回应可能有点愤世嫉俗;但我全都告诉了他们:

It will be a long time before I trust software to drive car I am in.
Because I – know.

在我相信软件驾驶我的车之前，还需要很长一段时间。
因为我知道。

What is it that I know?
I know just how hard it is to test software systems for every contingency. 
And I know just easy it is to fool yourself that you have.

我知道的是什么？
我知道测试软件系统的每一种意外情况是多么困难。
我知道骗自己很容易，你有。

And that started me thinking about how you should test the software for a self-driving car.

这让我开始思考应该如何测试自动驾驶汽车的软件。

And that started me thinking about how people do test software systems.

这让我开始思考人们是如何测试软件系统的。

And that finally started me thinking about stabilization phases.

这让我开始思考稳定阶段。

You know what a stabilization phase is, don’t you? 
A stabilization phase occurs at the end of a release. 
Time is set aside to just let the system run. 
For a week, or a month, everybody just watches the system run. 
They treat it like a sleeping baby. 
They avoid loud noises, slamming doors, and loud conversation. 
They tiptoe around, peeking in on it from time to time, hoping that it won’t wake-up and fail.

你知道稳定阶段是什么吧?
稳定阶段发生在发布的末尾。
留出时间让系统运行。
在一个星期或一个月的时间里，每个人都只是观察系统的运行。
他们把它当成熟睡的婴儿。
他们避免噪音、摔门和大声交谈。
他们蹑手蹑脚地四处走动，不时地偷窥它，希望它不会醒来而失败。

OK, maybe that’s a little over the top. – Maybe. 
I imagine most teams who run stabilization phases actually work pretty hard to stress their systems. 
At least I hope they do. They should be running lots of data through the system under varying loads;
including data that is malformed, and that has caused problems in the past.
 
好吧，可能有点过了。——也许。
我想大多数运行稳定阶段的团队实际上都非常努力地给他们的系统施加压力。
至少我希望他们会。他们应该在不同负载下通过系统运行大量数据;
包括那些畸形的数据，以及那些在过去引起过问题的数据。

But here’s the thing about Stabilization phases:

但关于稳定阶段的问题是:

We run them because we are afraid. We are afraid because we are uncertain what the system will do.

我们经营它们是因为我们害怕。我们害怕是因为我们不确定这个系统会做什么。

There is a certain dissonance between calling ourselves professionals, 
and being so uncertain about what we have created that we fear what it might do. 
One would expect a team of professionals to have a high degree of confidence and certainty.

我们自称专业人士，
对我们创造的东西如此不确定，以至于我们害怕它会做什么。
人们期望一个专业团队具有高度的信心和确定性。

The longer a team wants a stabilization phase to run, the less certain that team is about the system. 
The teams who only need a day are much more certain about their systems than the teams who want a week, or a month.

团队希望稳定阶段运行的时间越长，团队对系统的确定性就越低。
只需要一天的团队比需要一周或一个月的团队更确定他们的系统。

The logical flaw here is that execution time indicates quality. 
But time is actually unrelated to quality. Time simply raises false confidence.

这里的逻辑缺陷是，执行时间表示质量。
但时间实际上与质量无关。时间只会带来虚假的信心。

The behavior of the system in the stabilization phase has little to no bearing on the behavior of the system in production; 
because the data coming into the system in production is entirely new data. 
That new data may drive the system down pathways that the stabilization phase never executed.

系统在稳定阶段的行为对系统在生产阶段的行为几乎没有影响;
因为在生产中进入系统的数据是全新的数据。
新数据可能会推动系统沿着稳定阶段从未执行过的路径前进。

So stabilization phases are really just about creating false confidence. 
They are a CYA strategy. When the system fails in production, you can at least claim that you performed the due diligence of running the system for a month in the stabilization phase; 
thereby exonerating the team from the culpability of leaving a critical defect in the system.

所以稳定阶段实际上只是为了制造错误的信心。
这是CYA策略。当系统在生产中出现故障时，您至少可以声称您在稳定阶段运行了一个月的系统;
从而免除团队在系统中留下重大缺陷的罪责。

The crux of the issue is that stabilization phases exist because the development team has produced code that they are not certain of. 
So they run the system for a month in order to create enough false confidence to counter that uncertainty.

问题的关键在于稳定阶段的存在，因为开发团队产生了他们不确定的代码。
因此，他们运行了一个月的系统，以创造足够的虚假信心来对抗这种不确定性。

What the team really needs to do is attack their uncertainty directly. 
Not by uselessly running the system for a month; but by correcting the deficits in their development process that led to their uncertainty. 
Consider the following checklist:

团队真正需要做的是直接解决他们的不确定性。
不是无用地运行一个月;但通过纠正导致其不确定性的发展过程中的赤字。
考虑以下清单:

Are you running coverage tools? Do you check that every if statement and while loop are covered? Is the unit-test coverage close to 100%. 
Do you need to drive it a bit higher by writing more unit tests?
Do you have automated acceptance tests written by (or at least validated by) the business and QA? Is the coverage of these tests high enough? 
Do you need to drive it higher by asking QA to consider more corner cases?
Do you have automated integration tests written by architects and development leads. 
Do those tests stress the communications pathways between the components? Do they check for corner cases, boundary issues, and timeouts? 
Do they probe system behavior under varying loads?
If you have multiple threads, do you have a strategy for stressing those threads during your unit tests and acceptance tests? 
For example, have you implemented tools that introduce random delays and random loads so that the chances of race conditions are magnified. 
Better yet, are you gradually eliminating the possibility of race conditions by eliminating mutable state between threads? 
Have you drawn all the message sequence charts and examined them for potential races?
This checklist is just an example. I’m sure you can think of more things to put on it. 
The point is that it is better to be proactive about your uncertainty, than it is to be passive about it. And stabilization phases are passive.



The goal of software teams who are currently using stabilization phases should be to increase their certainty over time, and thereby decrease the duration of their stabilization phases. Decrease them from a month, to a week. Then from a week to a day. Then from a day to an hour.

And then, finally, increase your certainty to the point that you can eliminate the stabilization phase once and for all.

Anecdote:

I recently test drove a Tesla. It’s a fun car to drive. I mean, really fun. I tried the “auto-steer” feature, which is easily engaged by double clicking a button on the steering column. The car happily informs you that the car is now driving itself; and warns you to keep your hands on the wheel. Heed that warning!

The car did tolerably well when the road markings were visible, but seemed quite willing to plow me into a bunch of construction barricades too. It is not safe to take your hands off the wheel or your eyes off the road. To me, that makes the feature rather less than useless.

The salesman was sitting next to me. At one point we were going 45mph towards the rear end of a car stopped at a red light. The salesman said: “Trust the car.” And I thought: “The hell I will!” And I applied the brakes.

This technology is cute; but dangerous. NEVER “trust the car”!

Perhaps you can tell that the prospect of self-driving cars does not fill me with enthusiasm. I shall continue to wonder just what those cars will do one second after midnight on February 29th.

### 3. 点评


## Tip
### 标题


## Share
### 标题