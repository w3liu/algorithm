# 2020.09.07-2020.09.13

## Algorithm
### 1. 题目
```
165. 比较版本号
```
### 2. 题目描述
```
比较两个版本号 version1 和 version2。
如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。

你可以假设版本字符串非空，并且只包含数字和 . 字符。

 . 字符不代表小数点，而是用于分隔数字序列。

例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。

你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。
 

示例 1:

输入: version1 = "0.1", version2 = "1.1"
输出: -1
示例 2:

输入: version1 = "1.0.1", version2 = "1"
输出: 1
示例 3:

输入: version1 = "7.5.2.4", version2 = "7.5.3"
输出: -1
示例 4：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。
示例 5：

输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。
 

提示：

版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。
版本字符串不以点开始或结束，并且其中不会有两个连续的点。
```

### 3. 解答：
```golang
func compareVersion(version1 string, version2 string) int {
	var i int
	v1 := split(version1)
	v2 := split(version2)
	for i < len(v1) && i < len(v2) {
		r := judge(v1[i], v2[i])
		if r != 0 {
			return r
		}
		i++
	}
	if i < len(v1) {
		if checkNum(v1[i:]) {
			return 1
		}
	}
	if i < len(v2) {
		if checkNum(v2[i:]) {
			return -1
		}
	}
	return 0
}

func split(s string) []string {
	return strings.Split(s, ".")
}

func judge(s1 string, s2 string) int {
	s1 = strings.TrimLeft(s1, "0")
	s2 = strings.TrimLeft(s2, "0")
	if len(s1) == 0 && len(s2) == 0 {
		return 0
	}
	if len(s1) == 0 {
		return -1
	}
	if len(s2) == 0 {
		return 1
	}
	a1, _ := strconv.Atoi(s1)
	a2, _ := strconv.Atoi(s2)
	if a1 > a2 {
		return 1
	}
	if a1 < a2 {
		return -1
	}
	return 0
}

func checkNum(nums []string) bool {
	for i := 0; i < len(nums); i++ {
		r := judge(nums[i], "")
		if r == 1 {
			return true
		}
	}
	return false
}
```
### 4. 说明
1. 分割字符串
2. 将字符串数组元素转换为数字，然后单独对比
3. 更长数组剩余元素是否含有数字

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### 标题


## Share
### 标题