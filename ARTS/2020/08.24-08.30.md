# 2020.08.24-2020.08.30

## Algorithm
### 1. 题目
```

```
### 2. 题目描述
```

```

### 3. 解答：
```golang

```
### 4. 说明


## Review
### 1. 原文链接
[https://medium.com/tendermint/tendermint-0-34-protocol-buffers-and-you-8c40558939ae](https://medium.com/tendermint/tendermint-0-34-protocol-buffers-and-you-8c40558939ae)

### 2. 翻译
What exactly is happening?

到底发生了什么？

Serialization

序列化

Tendermint Core uses Amino for both wire and disk serialization, and for these use cases, we’ll be replacing it completely with Protocol Buffers. 
Previously, we defined our own types in Go, and then Amino would use reflection to serialize them for us. 
But now we’ll be using types generated by Protocol Buffers throughout the codebase, including in the Go APIs we expose to the Cosmos SDK and other applications. 
Protocol Buffers will serialize these data structures for us “for free,” without us needing to write additional code.

Tendermint Core将Amino用于报文序列化和磁盘序列化，这些用例中，我们完全可以使用Protocol Buffers来取代它。
以前，我们用GO语言定义我们得类型，Amino将使用反射机制为我们序列化它们。
但现在我们将在整个代码库中使用Protocol Buffers生成的类型，包括我们向Cosmos SDK和其他应用程序公开的Go api。
Protocol Buffers将为我们“自由的”序列化这些数据结构，不需要我们去写额外的代码。

JSON Encoding

JSON 编码

Tendermint Core also uses Amino to generate JSON. This has caused some pain with the Rust implementation, so we’ve been keen to replace Amino here as well. 
However, the JSON that Amino produces includes distinctive choices about how to encode numbers and missing/nil values. 
Perhaps most notably, it also has a particular way of handling Go interfaces while encoding to JSON. 
All of this means that switching to a different JSON encoder right off the bat would deeply break applications.

Tendermint Core生成JSON也是用Amino。在Rust实现的时候会有一些痛点，我们
然而，Amino生成的JSON包含了关于如何编码数字和缺失/空值的独特选择。
也许最值得注意的是，在编码到JSON时，它还有一种处理Go接口的特殊方式。
所有的这些意味着切换到不同的JSON编码器会严重破坏应用程序。

 (There’s also the question of which JSON encoder we’d want to use: 
 There are pros and cons associated with every option, including the native Go encoder, the json-pb encoder, and the JSON schema encoder.)
For 0.34, we’ve decided to write a small wrapper which will produce “Amino-flavored” JSON from our generated types. 
This will allow us to remove Amino as a JSON encoding dependency, without breaking the interface for applications. 
It also means that we will be maintaining our own serialization code; however, it is small (~500 lines), limited in scope, and relatively easy to understand.

（还有一个问题是我们想要使用哪个JSON编码器：
每个选项都有优缺点，包括原生Go编码器、JSON -pb编码器和JSON模式编码器。）
对于0.34，我们决定编写一个小包装器，它将根据生成的类型生成“Amino风格”的JSON。
这将允许我们删除作为JSON编码依赖的Amino，而不会破坏应用程序的接口。
它意味着我们将维护我们自己序列化代码；然而，它很小（大约500行），范围有限，而且比较容易理解。

What do you need to do to ensure compatibility with Tendermint 0.34+?

为了保证兼容tendermint 0.34及以上的版本，你需要做些什么呢？

The Protocol Buffers migration itself doesn’t necessitate any code changes from client applications; 
however, there are a handful of code changes necessary for other features in 0.34. 
Fortunately, these changes are fairly minor and limited to the Application-Blockchain Interface (ABCI). 
The ABCI changes include a number of new methods, all of which run on a new ABCI connection and which enable the new state sync feature:
ListSnapshots
LoadSnapshotChunk
OfferSnapshot
ApplySnapshotChunk

Protocol Buffers迁移本身不需要从客户端应用程序更改任何代码;
然而，对于0.34版本中的其他特性，需要对代码做一些修改。
幸运的是，这些变化相当小，而且仅限于应用程序区块链接口(ABCI)。
ABCI的变更包括一些新方法，所有这些都运行在一个新的ABCI连接上，并启用了新的状态同步功能：
ListSnapshots
LoadSnapshotChunk
OfferSnapshot
ApplySnapshotChunk

At a minimum, you can simply implement these functions as no-ops in order to maintain the interface.
However, if you want your application to implement state sync, you’ll have to implement these methods within your application. 
We’ll be releasing a “user guide” for state sync soon, with more information on how to best implement these methods.

为了维护接口，您至少可以简单地将这些函数实现为no-ops。
然而，如果你想让你的应用程序实现状态同步，你必须在你的应用程序中实现这些方法。
我们将很快发布状态同步的“用户指南”，提供更多关于如何最好地实现这些方法的信息。

There is also one change to an existing ABCI message:
The “Proof” field of the “ResponseQuery” message is now called “ProofOps.”
These changes comprise ABCI version 0.17.0.
In addition to making changes to ABCI, this upgrade does change the way that state is encoded, and so this is a “state-breaking” change. 
Since encoded state is hashed, all the hashes for replayed blocks will change as well. 
For more details on which pieces of state are getting encoded differently, please see upgrading.md.
Networks upgrading to Tendermint 0.34 will need to conduct a network upgrade in order to update. 
This coordination will be done by the networks themselves; 
for example, if you are operating a node on the Cosmos Hub, this upgrade will likely be orchestrated through the next Hub upgrade.
One caveat: The IBC implementation inside the Cosmos SDK itself will need to make more expansive changes to the IBC Tendermint client in order to work with Tendermint 0.34. 
Because that implementation uses types that are generated by Protocol Buffers, and those types live inside Tendermint, some coordination between the Cosmos SDK and Tendermint was required.

对现有的ABCI消息也有一个更改:
“ResponseQuery”消息的“Proof”字段现在被称为“ProofOps”。
这些变化包括ABCI 0.17.0版本。
除了对ABCI进行更改之外，这次升级还改变了状态编码的方式，因此这是一种“打破状态”的更改。
因为编码的状态是Hash的，所以重播块的所有Hash也会改变。
了解关于状态的不同编码方式的详细信息，请查阅upgrading.md。
网络升级到Tendermint 0.34将需要进行网络升级，以便更新。
这种协调将由各网络本身进行;
例如，如果您在Cosmos中心上操作一个节点，则此升级可能会在下一次中心升级时进行协调。
需要注意的是:Cosmos SDK内部的IBC实现本身需要对IBC Tendermint客户端进行更广泛的更改，才能使用Tendermint 0.34。
因为该实现使用Protocol Buffers生成的类型，并且这些类型存在于Tendermint中，所以Cosmos SDK和Tendermint之间需要一些协调。

Risks

风险

Although there are lots of good reasons to make this change, it’s still a big change. Many lines of code have been added, deleted, generated and regenerated. 
And any time there’s this much churn, there’s an increased risk of introducing bugs or causing other accidents. 
To defend against this, we’re taking a number of precautions, and will be rigorous about testing and verifying this release in order to mitigate the risks.

尽管有很多好的升级的理由，但它始终是一个大的改变。加入、删除、生成以及重新生成了很多行代码。
任何时候有这么多的搅动，就会增加引入bug或引起其他事故的风险。
为了防范这种情况，我们正在采取一些预防措施，并将严格测试和验证此版本，以降低风险。

Mitigation: Integration and Unit Testing

缓解:集成和单元测试

As a baseline risk mitigation strategy, we’re emphasizing unit and integration testing across the Tendermint Core codebase. 
The team has worked hard to improve unit tests, increase coverage, and reduce non-determinism in tests as part of this release. 
Additionally, we’ve doubled down on increasing our “unhappy path” coverage.

作为一种减少风险的基线策略，我们强调贯穿Tendermint Core代码库的单元测试和集成测试。
团队为改善单元测试而努力工作，增加覆盖率，减少测试中的不确定性作为这个版本的一部分。
此外，我们加倍增加了“不愉快路径”的覆盖率

Mitigation: Testnets

缓解：测试网络

We’ll be running a number of testnets, internally and publicly, in order to test this release, both with and without the Cosmos SDK; and with and without previous Hub data. 
The exact details are still forthcoming, but the public testnets will be a cross-entity collaboration including teams working on the Cosmos SDK, Tendermint KMS, and more.
If you are a validator and are interested in participating in these testnets, please let us know! The more participants we have, the more confidence we will have in this exciting new release. 
The Tendermint Core team is available in the Cosmos Discord and we’d love to chat.

为了测试这个版本，我们将运行大量的内部和公共的测试网络，不管有没有使用Cosmos SDK；以及有无以前的HUB数据。
确切的细节还在后面，但是公开的testnets将是一个跨实体的协作，包括Cosmos SDK、Tendermint KMS等团队。
如果你是一个验证者，并有兴趣参与这些测试网，请让我们知道!我们拥有的参与者越多，我们对这个激动人心的新版本就越有信心。
Tendermint Core团队在Cosmos Discord中，我们很乐意聊天。

Mitigation: Public Release Candidates
Ahead of the official 0.34 release, we’ll be working with a number of partner projects, who will run public release candidates with their own software and projects. 
Successfully integrating the release candidates with ecosystem projects will help us build confidence in the official release.
If you’re interested in being one of our test partners, please get in touch! Again, getting a broad set of partners involved will help us release software that is stable and secure.

缓解：公开发布的候选人
在0.34正式发布之前，我们将与许多合作伙伴项目合作，他们将使用自己的软件和项目运行公共发布候选版本。
成功地将候选版本与生态系统项目集成将帮助我们建立对正式版本的信心。
如果您有兴趣成为我们的测试合作伙伴，请与我们联系!再次，获得广泛的合作伙伴将帮助我们发布稳定和安全的软件。

Future work

未来的工作

Protobuf Tooling Change
Although Protocol Buffers themselves are highly standardized, there exists a wide range of tooling to generate source code from .proto files. 
At the moment, both the SDK and Tendermint Core use a combination of compiler “plugins” and “extensions” which modify the way that code gets generated. 
However, due to divergent requirements, Tendermint Core and the SDK would like to use slightly different Protocol Buffer tooling sets. 
See the Proto Compilers, Extensions Future Work document for more details on the background and requirements.
In theory, it should be OK for different applications to use different proto tooling — as long as the generated types are only used internally. 
Unfortunately, Tendermint currently exposes generated types in its public Go APIs, which means that we have to use exactly the same generated types as our applications, which means that we must use the same proto compilation tools.
So in order to maintain compatibility with the SDK, we are using the same tools — for now. 
We intend to ultimately switch to a different set of compilation tools, although this will require us to rewrite our public Go API to use “domain” types rather than generated types.

Protobuf 工具改变
尽管Protocol Buffers本身是高度标准化的，有很多的工具从.proto文件生成源代码。
目前，SDK和Tendermint Core都使用了编译器“插件”和“扩展”的组合，它们可以修改代码生成的方式。
但是，由于需求分歧，Tendermint Core和SDK希望使用稍微不同的Protocol Buffers工具集。
有关背景和需求的更多细节，请参阅Proto编译器、扩展未来工作文档。
理论上，不同的应用程序可以使用不同的Proto工具——只要生成的类型只在内部使用。
不幸的是，Tendermint目前在它的公共Go api中公开了生成的类型，这意味着我们必须使用与应用程序完全相同的生成类型，这意味着我们必须使用相同的原型编译工具。
因此，为了保持与SDK的兼容性，目前我们使用相同的工具。
我们打算最终切换到一组不同的编译工具，尽管这将要求我们重写公共Go API以使用“域”类型而不是生成的类型。

JSON Encoding, Part II

第二部分，JSON编码

As described above, we’re currently continuing to encode JSON in an “Amino-flavored” way. We intend to change this at some point in the future, to something more standard. 

如上所述，我们目前正在继续以一种“Amino风格”的方式对JSON进行编码。我们打算在将来的某个时候改变它，使之更加标准。

This decision will be influenced by other open questions, such as whether we want to adopt gRPC. As it will not directly impact Tendermint 0.34, we haven’t made this decision yet.

这一决定将受到其他未决问题的影响，例如我们是否要采用gRPC。因为它不会直接影响到Tendermint 0.34，所以我们还没有做出决定。

### 3. 点评
略

## Tip
### 标题


## Share
### 标题