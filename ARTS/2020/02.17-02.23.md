# 2020.02.17-2020.02.23

## Algorithm
### 1. 题目
```
1206. 设计跳表
```
### 2. 题目描述
```
不使用任何库函数，设计一个跳表。

跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作：

```

[!qr](./images/0203_t_1.png)

```
Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons

跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。

在本题中，你的设计应该要包含这些函数：

bool search(int target) : 返回target是否存在于跳表中。
void add(int num): 插入一个元素到跳表。
bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。
了解更多 : https://en.wikipedia.org/wiki/Skip_list

注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。

样例:

Skiplist skiplist = new Skiplist();

skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
约束条件:

0 <= num, target <= 20000
最多调用 50000 次 search, add, 以及 erase操作。
```

### 3. 解答：
```golang
const MaxLevel = 16

// 节点
type Node struct {
	Val       int     // 节点值
	NextNodes []*Node // 下一个节点所有层级
	Count     int     // 相同值数量
}

func NewNode(level int) *Node {
	return &Node{
		Val:       -1,
		NextNodes: make([]*Node, level),
		Count:     1,
	}
}

type Skiplist struct {
	levelCount int // 索引区间
	head       *Node
}

func Constructor() Skiplist {
	return Skiplist{
		levelCount: 1,
		head:       NewNode(MaxLevel),
	}
}

func randLevel() int {
	level := 1
	for i := 1; i < MaxLevel; i++ {
		if rand.Int31()%2 == 1 {
			level++
		}
	}
	return level
}

func (this *Skiplist) Search(target int) bool {
	var p = this.head
	for i := this.levelCount - 1; i >= 0; i-- {
		for p.NextNodes[i] != nil && p.NextNodes[i].Val < target {
			p = p.NextNodes[i]
		}
	}
	if p.NextNodes[0] != nil && p.NextNodes[0].Val == target {
		return true
	}
	return false
}

func (this *Skiplist) Add(num int) {
	var level int
	if this.head.NextNodes[0] == nil {
		level = 1
	} else {
		level = randLevel()
	}
	if level > this.levelCount {
		this.levelCount = this.levelCount + 1
		level = this.levelCount
	}
	var node = NewNode(level)
	node.Val = num
	var updates = make([]*Node, level)
	for i := 0; i < level; i++ {
		updates[i] = this.head
	}
	var p = this.head
	for i := level - 1; i >= 0; i-- {
		for p.NextNodes[i] != nil && p.NextNodes[i].Val <= num {
			p = p.NextNodes[i]
		}
		updates[i] = p
	}
	for i := 0; i < level; i++ {
		if updates[i].NextNodes[i] != nil && updates[i].NextNodes[i].Val == num {
			updates[i].NextNodes[i].Count = updates[i].NextNodes[i].Count + 1
		} else {
			node.NextNodes[i] = updates[i].NextNodes[i]
			updates[i].NextNodes[i] = node
		}
	}
}

func (this *Skiplist) Erase(num int) bool {
	var updates = make([]*Node, this.levelCount)
	var p = this.head
	for i := this.levelCount - 1; i >= 0; i-- {
		for p.NextNodes[i] != nil && p.NextNodes[i].Val < num {
			p = p.NextNodes[i]
		}
		updates[i] = p
	}
	if p.NextNodes[0] != nil && p.NextNodes[0].Val == num {
		for i := this.levelCount - 1; i >= 0; i-- {
			if updates[i].NextNodes[i] != nil && updates[i].NextNodes[i].Val == num {
				if updates[i].NextNodes[i].Count > 1 {
					updates[i].NextNodes[i].Count = updates[i].NextNodes[i].Count - 1
				} else {
					updates[i].NextNodes[i] = updates[i].NextNodes[i].NextNodes[i]
				}
			}
		}
		return true
	}
	return false
}
```
### 4. 说明
调表实现还是比较复杂的，这道题关键点在于用巧妙的方式构建了跳表的层级，通过NextNodes数组进行了关联。
另外，相同的数组用Count字段进行标记，这样节约了内存。

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### 标题


## Share
### 标题