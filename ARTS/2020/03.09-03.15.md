# 2020.03.09-2020.03.15

## Algorithm
### 1. 题目
```
4. 寻找两个有序数组的中位数
```
### 2. 题目描述
```
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

### 3. 解答：
```golang
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	m := len(nums1)
	n := len(nums2)
	if m > n {
		nums1, nums2 = nums2, nums1
		m, n = n, m
	}
	iMin := 0
	iMax := m

	for iMin <= iMax {
		i := (iMin + iMax) / 2
		j := (m+n+1)/2 - i
		if i < iMax && nums2[j-1] > nums1[i] {
			iMin = i + 1
		} else if i > iMin && nums1[i-1] > nums2[j] {
			iMax = i - 1
		} else {
			maxLeft := 0
			if i == 0 {
				maxLeft = nums2[j-1]
			} else if j == 0 {
				maxLeft = nums1[i-1]
			} else {
				maxLeft = int(math.Max(float64(nums1[i-1]), float64(nums2[j-1])))
			}
			if (m+n)%2 == 1 {
				return float64(maxLeft)
			}
			minRight := 0
			if i == m {
				minRight = nums2[j]
			} else if j == n {
				minRight = nums1[i]
			} else {
				minRight = int(math.Min(float64(nums1[i]), float64(nums2[j])))
			}
			return float64(maxLeft+minRight) / float64(2)
		}
	}
	return 0
}

func findMedianSortedArrays0(nums1 []int, nums2 []int) float64 {
	nums := make([]int, 0)
	var j = 0
	for i := 0; i < len(nums1); i++ {
		for j < len(nums2) {
			if nums1[i] <= nums2[j] {
				nums = append(nums, nums1[i])
				break
			} else {
				nums = append(nums, nums2[j])
				j++
			}
		}
		if j >= len(nums2) {
			nums = append(nums, nums1[i])
		}
	}
	if j < len(nums2) {
		nums = append(nums, nums2[j:]...)
	}
	return getMid(nums)
}
```
### 4. 说明
提供两种思路，第一种思路复杂度是O(log(m+n))，第二种思路复杂度是O(m*n)

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### 标题


## Share
### 标题