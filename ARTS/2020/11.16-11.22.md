# 2020.11.16-2020.11.22

## Algorithm
### 1. 题目
```
98. 验证二叉搜索树
```
### 2. 题目描述
```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

```


### 3. 解答：
```golang
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
	return compare(root, math.MinInt64, math.MaxInt64)
}

func compare(root *TreeNode, lower, upper int) bool {
	if root == nil {
		return true
	}
	if root.Val <= lower || root.Val >= upper {
		return false
	}
	return compare(root.Left, lower, root.Val) && compare(root.Right, root.Val, upper)
}
```
### 4. 说明
采用递归的方法，最重要的事找到终止条件，并且要把最小值和最大值带到比较函数中去


## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### golang mutex
1. Mutex结构体
    * Mutex.state表示互斥锁的状态，比如是否被锁定等。
        - Locked:表示该Mutex是否已被锁定，0：没有锁定，1：已被锁定。
        - Woken:表示是否有协程已被唤醒，0：没有被唤醒，1：已有协程被唤醒，正在加锁过程中。
        - Starving:表示该Mutex是否处于饥饿状态，0：没有饥饿，1：饥饿状态，说明有协程阻塞了超过1ms。
        - Waiter:表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。
    * Mutex.sema表示信号量，协程阻塞等待该信号，解锁的协程释放信号量从而唤醒等待信号的协程。
2. 自旋条件
    * 自旋次数要足够小，通常为4，即自旋最多4次
    * CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁
    * 协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋
    * 协程调度机制中的可运行队列必须为空，否则会延迟协程调度
3. Tips
    * 加锁后立即使用defer对其解锁，可以有效避免死锁。
    * 加锁和解锁应该成对出现，比如同一个函数中，重复解锁会引起panic。

## Share
### 程序员如何把控自己的职业
[https://coolshell.cn/articles/20977.html](https://coolshell.cn/articles/20977.html)