# 2020.07.27-2020.08.02

## Algorithm
### 1. 题目
```
509. 斐波那契数
```
### 2. 题目描述
```
斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

 

示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：

输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：

输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
 

提示：

0 ≤ N ≤ 30
```

### 3. 解答：
```golang
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	return fib(N-1) + fib(N-2)
}
```
### 4. 说明
采用递归算法即可

## Review
### 1. 原文链接
[Everything you need to know about the Tendermint Light Client](https://medium.com/tendermint/everything-you-need-to-know-about-the-tendermint-light-client-f80d03856f98)

### 2. 翻译

Part 2: Core principles and algorithms

第二部分：核心原则与算法

2.1 Weak subjectivity

2.1 脆弱的主观性

Now, how do we make sure that the first header we obtain from a full node can be trusted? 
Remember, we don’t have any prior knowledge except the consensus algorithm and genesis info (genesis.json file and genesis block #1).

现在，我们如何确保我们从一个全节点获得的第一个区块头是可信的？
记住，我们没有任何先验知识除了共识算法和创世信息（genesis.json文件与创世块）。

We could fetch the genesis header and try to sync to the latest state from it, but that would be:

我们可以获取创世头并尝试从它同步至最近的状态，但是那将是：

· Theoretically unsafe because it is costless for an attacker to buy up voting keys that are no longer bonded and fork the network at some point in its prior history (aka a long-range attack). 
Remember that when a new validator joins a Proof-Of-Stake network, it must putX amount of tokens into a special account (stake/bond them). 
If it does something bad, its stake will be slashed. 
When it decides to get its tokens out, it signals the network desire to unbond. 
After a certain amount of time (unbonding window), it gets the tokens back.

· 理论上讲是不安全的，因为对攻击者来说，购买不再绑定的投票密钥并在网络以前的某个节点分叉是没有成本的(又称远程攻击)。
记住当一个新的验证者加入一个股权证明网络的时候，它必须将若干数量的代币放进一个特殊的账户（股权/债权他们）。



- 核心词汇
`Theoretically` 理论上
`aka` 又名


### 3. 点评


## Tip
### 标题


## Share
### 标题