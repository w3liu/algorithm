# 2020.03.30-2020.04.05

## Algorithm
### 1. 题目
```
79. 单词搜索
```
### 2. 题目描述
```
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
 

提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3

```

### 3. 解答：
```golang
func exist(board [][]byte, word string) bool {
	l := len(board)
	w := len(board[0])

	for i := 0; i < l; i++ {
		for j := 0; j < w; j++ {
			if dfs(board, word, i, j, 0) {
				return true
			}
		}
	}
	return false
}

func dfs(board [][]byte, word string, i, j, k int) bool {
	if k == len(word) {
		return true
	}
	if i < 0 || j < 0 || i == len(board) || j == len(board[i]) {
		return false
	}
	if board[i][j] != word[k] {
		return false
	}
	tmp := board[i][j]
	board[i][j] = byte(0)
	index := k + 1
	if dfs(board, word, i-1, j, index) || // 向左
		dfs(board, word, i+1, j, index) || // 向右
		dfs(board, word, i, j-1, index) || // 向下
		dfs(board, word, i, j+1, index) { // 向上
		return true
	}
	board[i][j] = tmp
	return false
}
```
### 4. 说明
这道题主要是采用了递归加深度优先搜索算法，最重要的一点是将访问过元素标记为0避免回溯的时候重复访问。

## Review
### 1. 原文链接
[https://www.infoq.com/news/2017/04/blockchain-cap-theorem/](https://www.infoq.com/news/2017/04/blockchain-cap-theorem/)

### 2. 翻译

The Blockchain and the CAP Theorem

区块链与CAP理论

Yaron Goland, principal architect at Microsoft, has published an article describing how a blockchain client can be made AP or CP based on its implementation. 
This works by being able to configure how many blocks must come after a transaction until it is accepted. 
The more blocks which have occurred after the transaction, the more likely it is to have a system wide consensus, making it consistent.





### 3. 点评


## Tip
### MongoDB与微服务
1. 微服务的优势
    * 开发速度快
    * 变化响应快
    * 易维护
    * 扩容简单
2. 微服务架构设计要素
    * 服务解耦（Decouple）
    * HTTP API - 简单接口（Dumb Pipes）
    * 数据去中心化（Decentralize）
    * 持续集成自动部署（DevOps）
3. 微服务架构设计考量点
    * 一服务一库还是多服务一库
    * 混合持久化还是多模数据库
    * 扩容便捷性
4. 多个微服务共享一个数据库的缺点
    * 单点故障，一个服务性能问题可能拖垮整个服务集群
    * 容易引起强关联，不利解耦
    * 难以为某一个微服务单独扩容
5. 关键服务使用自己的库
    * 每个微服务使用一个逻辑库
    * 数据库变动时不影响其他服务
6. 混合持久化
    * 为关键服务提供最适合的数据库
    * 学习成本，管理成本和硬件成本高
7. 多模数据库
    * 一种数据库，多种模式
    * 一种技术，学习及管理简单
    * 可以单独优化
8. 是否可以快速扩容
    * 水平扩展应用
    * 微服务化
    * 数据扩容
9. MongoDB容器化部署
    MongoDB是一个有状态的服务，在容器化部署的时候要特别注意
        * 复制集节点要能够相互通讯：配置的时候要使用服务名，或者固定的服务IP地址
        * 使用Persistent volume 或类似长久存储
        * 使用Ops Manager进行集群管理（而不是k8s/OpenShift）

## Share
### 谁说区块链是保护隐私的？
[https://www.infoq.cn/article/VqKXbRdSkw3rVvgBgcb0](https://www.infoq.cn/article/VqKXbRdSkw3rVvgBgcb0)