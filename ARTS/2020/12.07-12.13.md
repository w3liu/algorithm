# 2020.12.07-2020.12.13

## Algorithm
### 1. 题目
```

```
### 2. 题目描述
```

```

### 3. 解答：
```golang

```
### 4. 说明


## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### golang gc
1. 内存分配原理
* Golang内存分配器原理与tcmalloc类似
* 每个P维护着一小块的私有内存，私有内存不足再从全局申请
* Golang启动时会向系统申请的内存划分：
    - spans 为了管理arena区而存在
    - bitmap 为管理arena区而存在
    - arena 堆区，应用需要的内存从这里分配
* mcentral管理多个span供线程申请使用
* mcache作为线程私有资源，资源来源于mcentral

2. 垃圾回收原理
* 标记-清除方法
    - 从根变量开始遍历所有的引用对象
    - 引用的对象标记为"被引用"
    - 没有被标记的进行回收
* 内存标记
    - allocBits记录每块内存分配情况
    - gcmarkBits记录每块内存标记情况
    - 标记结束回收内存，同时将allocBits指向gcmarkBits
* 三色标记法
    - 灰色：对象还在标记队列中等待
    - 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
    - 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
3. 垃圾回收优化
* 写屏障
    - 让goroutine与GC同时运行的手段
    - 可以大大减少STW的时间
    - 在GC特定时机开启，开启后指针传递会把指针标记，即本轮不回收
    - GC过程中新分配的内存会被立即标记
* 辅助GC
    - 如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作
4. 垃圾回收触发时机
* 内存分配量达到阀值触发GC
    - 阀值 = 上次GC内存分配量 * 内存增长率
    - 内存增长率有环境变量GOGC控制，默认100，即每当内存扩大一倍时启动GC
* 定期触发GC
    - 默认情况下，最长2分钟触发一次GC
* 手动触发
    - 程序代码中，可以使用runtime.GC()，来手动触发GC
5. GC性能优化
* GC性能与对象数量负相关，对象越多GC性能越差
* GC性能优化思路之一是减少对象分配个数
    - 对象复用
    - 大对象组合多个小对象
6. 逃逸分析
* 逃逸策略
    - 如果函数外部没有引用，则优先放到栈中
    - 如果函数外部存在引用，则必定放到堆中
    - 函数外部没有引用的对象，也可能放到堆中，比如内存过大超过栈的存储能力
* 逃逸场景
    - 指针逃逸
    - 栈空间不足逃逸
    - 动态类型逃逸
        - 比如很多函数参数为interface类型，编译期间很难确定其参数具体类型
    - 闭包引用对象逃逸
* 逃逸总结
    - 栈上分配内存币在堆中分配内存有更高的效率
    - 栈上分配的内存不需要GC处理
    - 堆上分配的内存使用完毕会交给GC处理
    - 逃逸分析的目的是决定内存分配地址是栈还是堆
    - 逃逸分析在编译阶段完成
* 函数传递指针真的比传递值效率高吗？
    - 传递指针可以减少底层值的拷贝，可以提高效率
    - 但如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC负担
    - 所以，传递指针不一定是高效的


## Share
### 标题