# 2019.11.25-2019.12.01

## Algorithm
### 1. 题目
```
142. 环形链表 II（020）
```
### 2. 题目描述
```
对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

 

插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：

输入: 4->2->1->3
输出: 1->2->3->4
示例 2：

输入: -1->5->3->4->0
输出: -1->0->3->4->5

```

### 3. 解答：
```golang
type ListNode struct {
	Val  int
	Next *ListNode
}

func insertionSortList (head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	origin := &ListNode{Val:0, Next:head}
	curr := head
	tail := head
	for curr != nil {
		next := curr.Next
		// 当前节点和尾部节点相遇，不做任何处理，直接进入下一轮
		if tail == curr {
			curr = next
			continue
		}
		// 若干当前节点值大于尾部节点，尾部节点与当前节点做交换
		if curr.Val >= tail.Val {
			tail.Next = curr
			tail = curr
		} else {
			// 取出head节点的第一个节点
			seq := origin.Next
			// 取出origin节点的第一个节点（head的前置节点）
			pre := origin
			// 从头到尾开始遍历节点
			for seq != tail {
				// 如果遇到有大于当前节点的，则中断
				if seq.Val > curr.Val {
					break
				}
				pre = seq
				seq = seq.Next
			}
			// 执行插入排序
			curr.Next = seq
			pre.Next = curr
		}

		curr = next
	}
	// 尾部的Next需要置空，要不可能会出现死循环
	tail.Next = nil
	return origin.Next
}
```
### 4. 说明
```text
这道题费了大概5个小时才完成，看似简单，但稍不注意就会出现死循环。重点是需要设置一个origin节点指向head节点，这样会减少一些逻辑判断。
```

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### 标题


## Share
### 标题