# 2019.12.23-2019.12.29

## Algorithm
### 1. 题目
```
889. 根据前序和后序遍历构造二叉树（023）
```
### 2. 题目描述
```
返回与给定的前序和后序遍历匹配的任何二叉树。

 pre 和 post 遍历中的值是不同的正整数。

 

示例：

输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
 

提示：

1 <= pre.length == post.length <= 30
pre[] 和 post[] 都是 1, 2, ..., pre.length 的排列
每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。
```

### 3. 解答：
```golang

func constructFromPrePost(pre []int, post []int) *TreeNode {
	if len(pre) == 0 {
		return nil
	}
	root := &TreeNode{
		Val:   pre[0],
	}
	if len(pre) == 1 {
		return root
	}
	l := 0
	for i, v := range post {
		if v == pre[1] {
			l = i + 1
			break
		}
	}
	left := constructFromPrePost(pre[1:l+1], post[0:l])
	right := constructFromPrePost(pre[l+1:], post[l:len(post)-1])
	root.Left = left
	root.Right = right
	return root
}
```
### 4. 说明

我们令左分支有 L 个节点。我们知道左分支的头节点为 pre[1]，但它也出现在左分支的后序表示的最后。

所以 pre[1] = post[L-1]（因为结点的值具有唯一性），因此 L = post.indexOf(pre[1]) + 1。

现在在我们的递归步骤中，左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支，而右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支。

## Review
### 1. 原文链接


### 2. 翻译


### 3. 点评


## Tip
### 标题


## Share
### 标题